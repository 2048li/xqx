# CollectCNcc.pm
#
# This module is responsible for collecting call graph information via
# .nccout files generated by ncc. This requires ncc to be downloaded
# from http://students.ceid.upatras.gr/~sxanth/ncc/index.html
#
# Format of .nccout files is
#
# D: somefunction()	- Function beginning (i.e. sets currfunc)
# F: callee()		- Function call
# F: *strcture.field()  - Call of function pointer in structure
# G: variable		- Reference a global variable
# S: structure.field    - struct reference
#
# Currently, only function declaration and calls are used. Function pointers
# are ignored for the moment
#

package CodeViz::CollectCNcc;
use CodeViz::Graph;
require Exporter;
use vars qw (@ISA @EXPORT);
use strict;
no strict 'refs';

@ISA    = qw(Exporter);
@EXPORT = qw(&generate_cncc);

my $propdepth=2;

# generate_cncc - Collect data from C .nccout files and the graph
# $toplevel - Top level source directory
# $files    - Specific files that are to be scanned
# $subdirs  - List of subdirectories to graph
# $handle   - File handle to output graph
sub generate_cncc {
  my ($toplevel, $files, $subdirs, $handle) = @_;
  my $toplevel_escaped;
  my %F;		# Function declaration hash table
  my %M;		# Flags if function called 
  my %C;		# Call graph edge. Global as sorting function needs it
  my @sortedC;		# Sorted call graph
  my %printed;		# Hash table storing edges already printed
  my $file;		# Current source being parsed
  my $i;		# Index variable
  my ($f1, $f2);	# Two functions
  my $pfile;		# store file line

  # Get the top level escaped path
  $toplevel_escaped = $toplevel;
  $toplevel_escaped =~ s/\//\\\//g;
 
  # Begin scanning for files.
  if ($files != -1) {
    open(FIND, "echo $files|") or die("Failed to open pipe to 'echo'");
  } else {
    open(FIND, "find $subdirs -name \"*.nccout\"|") or die("Failed to open pipe to 'find'");
  }

  while(!eof(FIND)) { 

    # Remove the toplevel source directory name
    $file = <FIND>;
    chomp($file);
    $file =~ s/$toplevel_escaped//;

    # Open input file
    print "Opening: $file\n";
    open (F,"$toplevel$file") || return;

    # Read this input file
    while (!eof(F)) {
      $_ = <F>;
      # Lines beginning with D are function declarations
      # Lines beginning with F are calling a function
      # Lines beginning with P set the pfile variable
      # Lines beginning with L are function start-line end-line
      if (/^D: (.+)\(\)/) {
        $f1 = $1;
        $M{$f1}=3;
      } elsif (/^F: (.+)\(\)/) {
        $f2 = $1;
	$C{"$f1~$f2"}="$file:-1";
      } elsif (/^P: (.+)/) {
        $pfile = $1;
      } elsif (/^L: (.+)\(\) (.+) (.+)/) {
        $F{$1} = "$pfile:$2:";
      }
    }

    close F;
  }
  close FIND;

  print "Propagating call graph\n";
  for($i=0;$i<$propdepth;$i++) {
    foreach (keys %C) {
      next if (!/^(.+)~(.+)$/);
      $M{$2} |= 1 if ($M{$1} & 1);
      $M{$1} |= 2 if ($M{$2} & 2);
    }
  }

  # print result
  print "Sorting function calls\n";
  @sortedC = sort FuncFileSort keys %C;
  # Function sorting function. Functions are sorted by
  # filename alphabetically and then line number. This
  # is done to ensure the functions are outputted in
  # the right call order
  sub FuncFileSort {
    my ($lFunc, $rFunc);
    my ($lNum, $rNum);
    my $result;

    ($lFunc, $lNum) = split(/~/, $C{$a});
    ($rFunc, $rNum) = split(/~/, $C{$b});
  
    # Compare the filenames and return the result
    # if they are not the same
    $result = $lFunc cmp $rFunc;
    if ($result != 0) { return $result; }
  
    # Filenames are the same, so return the comparison
    # of the line numbers
    return $lNum <=> $rNum;
  }

  print "Outputting graph labels\n";
  while (($f1, $f2) = each %F) {
    printGraph($handle, "$f1 [label=\"$f1\\n$f2\"];\n"); 
  }

  print "Outputting call graph\n";
  foreach (@sortedC) {
    next if (!/^(.+)~(.+)$/); 
    $f1=$1; $f2=$2;
    next if (!($M{$f1} > 0));      # ignore not flagged caller

    # Strip away SMP mangling on symbols. This is very 
    # Linux specific but the names of the functions are
    # so weird, I cannot see it happening anywhere else.
    $f1 =~ s/_Rsmp_([0-9a-f]{8})$//;
    $f2 =~ s/_Rsmp_([0-9a-f]{8})$//;
    $f1 =~ s/_R([0-9a-f]{8})$//;
    $f2 =~ s/_R([0-9a-f]{8})$//;

    if ($printed{"$f1-$f2"} != 1)
    {
      $printed{"$f1-$f2"} = 1;
      printGraph($handle, "$f1 -> $f2;\n");
    }
   
  }
  print "Done\n";
  return 0;
}

1;
